# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.39
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package zinnia;
use base qw(Exporter);
use base qw(DynaLoader);
package zinniac;
bootstrap zinnia;
package zinnia;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package zinnia;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package zinnia;

*version = *zinniac::version;

############# Class : zinnia::Character ##############

package zinnia::Character;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( zinnia );
%OWNER = ();
%ITERATORS = ();
*set_value = *zinniac::Character_set_value;
*value = *zinniac::Character_value;
*set_width = *zinniac::Character_set_width;
*set_height = *zinniac::Character_set_height;
*width = *zinniac::Character_width;
*height = *zinniac::Character_height;
*clear = *zinniac::Character_clear;
*add = *zinniac::Character_add;
*strokes_size = *zinniac::Character_strokes_size;
*stroke_size = *zinniac::Character_stroke_size;
*x = *zinniac::Character_x;
*y = *zinniac::Character_y;
*parse = *zinniac::Character_parse;
*what = *zinniac::Character_what;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        zinniac::delete_Character($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = zinniac::new_Character(@_);
    bless $self, $pkg if defined($self);
}

*toString = *zinniac::Character_toString;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : zinnia::Result ##############

package zinnia::Result;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( zinnia );
%OWNER = ();
%ITERATORS = ();
*value = *zinniac::Result_value;
*score = *zinniac::Result_score;
*size = *zinniac::Result_size;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        zinniac::delete_Result($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : zinnia::Recognizer ##############

package zinnia::Recognizer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( zinnia );
%OWNER = ();
%ITERATORS = ();
*open = *zinniac::Recognizer_open;
*close = *zinniac::Recognizer_close;
*size = *zinniac::Recognizer_size;
*value = *zinniac::Recognizer_value;
*classify = *zinniac::Recognizer_classify;
*what = *zinniac::Recognizer_what;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        zinniac::delete_Recognizer($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = zinniac::new_Recognizer(@_);
    bless $self, $pkg if defined($self);
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : zinnia::Trainer ##############

package zinnia::Trainer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( zinnia );
%OWNER = ();
%ITERATORS = ();
*add = *zinniac::Trainer_add;
*clear = *zinniac::Trainer_clear;
*train = *zinniac::Trainer_train;
*convert = *zinniac::Trainer_convert;
*makeHeader = *zinniac::Trainer_makeHeader;
*what = *zinniac::Trainer_what;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        zinniac::delete_Trainer($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = zinniac::new_Trainer(@_);
    bless $self, $pkg if defined($self);
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package zinnia;

*VERSION = *zinniac::VERSION;
1;
